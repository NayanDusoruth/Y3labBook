{"title":"1.1 lab session notes","markdown":{"headingText":"1.1 lab session notes","containsRefs":false,"markdown":"\n\n## Potential plan (written 21/01/2026):\n\n* Lab induction\n* Dr Turci walks us through introduction\n* Discuss refactoring code to give us a \"complete virtual lab apparatus\":\n* A complete system which we can use to generate arbitrary configuration datasets for study\n* Setup github repo\n* Start refactoring/writing code (hopefully finish this quickly - that way rest of lab can be running simulations w/minimal need for more coding)\n\nReasoning for this:\n\n* What is needed from code seems fairly clear at this point; need to be able to generate arbitrary configurations simulated to equilibration; need to be able to extract arbitrary observables; need to be able to assemble these into datasets over parameter variation\n* Currently still going through \"percolation\" chapter \\cite{ComplexityAndCriticality} - understanding of theory isn't fully there yet, however understanding of code requirements ~ is - therefore start with what is known, and familiarise self with theory more later\n\n\n## Lab log (22/01/2026):\n\nTurci introduced us to project:\n* Gave us overview\n\n\nMet up w/lab partner, are trying to figure out project direction and logistical questions:\n* Setup shared google drive folder to share materials\n* Setup planning document\n\t* General starting aims:\n\t\t* Find critical exponents\n\t\t* Study cluster behavior\n\t\t* Vary over temperature and dimensionality\n* Agreed to refactor code in terms of config object\n\t* Object oriented config object w/pickle library save/load functionality - given that sims may be computationally intensive, saving results for future reanalysis may save compute time\n\t* Decided to use inheritance structure; parent config, and 1D, 2D, 3D, 4D config children - sim steps will look different in different dimensions and may be difficult to generalize - hence inheritance structure\n\nTalked to Turci:\n* Need to figure out when state converges\n\n* Setup code refactoring thus far:\n\t* Parent config class - has saving/load methods\n\t* Setup 2D config as test child case\n\n\nHave setup code in object oriented approach:\n\tAbstract config class\n\t2D config class\nHave done rudimentary testing\n\nTo do list:\n* FIX STATE LIST\n\n* Clean up code\n* Implement higher and lower dimensions classes\n* Read up and figure out critical exponents\n* Optimisation and factorisation:\n\t* Figure out numba python library; speed up system\n\t* Maybe rework observable lists into pandas dataframe? May be more generalisable/easier to work with\n\t* Double check observable calculations\n\t* Add \"average observables\" - need to be able to average over several iterations\n\t* Maybe save multiple config steps?\n* Potentially setup \"dataset\" object? Set of config objects along some varied quantity? Save to folder of \n\t\t\n\t\n* Setup github quarto lab book; switch over to lab book\n\n\n\n##Lab log (24/01/2026):\n\n* Decided to switch back to original state system for now; ik it works; may need to refactor it later\n* Gonna try and implement numba on 2D case; test everything in 2D, then can expand out to higher dimensions\n* Nvm; gonna try and get good bones in, and save all states\n\nFor current use, two general test cases:\n\n* standardTest2000 = Ising model 100x100 cells run for 2000 steps\n* standardTest500 = Ising model 100x100 cells run for 500 steps\n\n* Have implemented saving all states - it does make the saved files significantly larger (I.E, 100x100 model w/100 steps, saving energy/magnetization observables is 32.5Mb) - quick test standardTest2000 s; took several minutes (didn't time it, but took a while), saved to 192.5 Mb\n\t* Currently that is acceptable; (given 100x100x2000 = 2x10^7 stored cells)) that suggests each cell uses ~20 bytes of storage space; so extrapolating to a 3D case 100^3⋅2000=40Gb - a 4D case may be prohibitive w/~4Tb storage space for the same size; \n\t\t* Could add discard functionality (I.E, don't need the initial equilibration steps)\n\t\t* Could only save the observables over that simulation length\n\t\t* However for now having the default \"save all raw data\" option is good to have\n\n* Thinking of optimisations:\n\t* mcMove method\n\t* calcEnergy method\n\t* Both are VERY inefficient; in similar ways\n\t* Both run through entire configuration; both check adjacent cells; currently implemented through for loops; however some steps may be more efficiently done by either numpy array operations, or numba implementations\n\t* It may also be interesting to see if adjacency checks could be generalised/factorised to any dimension; if that’s possible, inheritance structure becomes unecessary, as the algorithm could be implemented for all dimensionalities\n\t\t* It would be very useful if generalising is possible; this would allow detailed study of higher dimensional ising models\n\t* Config state storage - currently an array of integer values; am wondering if can switch to a binary representation - would make storage of saved files more efficient (I.E, 4D 100x100x2000 case could optimistically be reduced to 200Gb)\n\t* Data discard system - options to discard all but the N most recent configurations - storage data optimisation\n\nIf its possible to generalise the dinemsionality of the model; that opens up more lines of investigation\n\nUnsure which optimisations are worth it.\nPlan of action:\n\n* Try and get numba working\n* Familiarise self w/numba operations\n* Try and refactor/optimise above with numba in mind\n\n\nGot numba working; doing rudimentary tests to see if it improves performance:\n\n* Adding numba decorator to mcMove method\n* standardTest500  yields Dt = 96.8 s\n* standardTest500  w/out numba yields: 92.2 s\n* This suggests no significant speedup\n\t* Suggests I'm using it incorrectly\n* Testing standardTest500  w/ provided code; \n\t* w/out numba: 38.8 s\n\t* W/ numba: 4.26 s\n* Maybe object oriented approach is breaking stuff?\n\t* Changed mc move; moved all self checks to runSimulation instead; that way mcMove is more \"anonymous\" and doesn't need to call self\n\t\t* standardTest500: 47.8 s\n\t\t* Significant improvement\n\t* Wondering if difference between provided code and own code is due to \"additional\" code run by \"simulationRun\" - have commented out plotting and appending observables\n\t\t* standardTest500: 7.3 s\n* Takeaways:\n\t* Since Numba compiles individual functions to machine code; it is advisable for numba accelerated functions/methods to be \"streamlined\" w/out needing to refer to non accelerated code\n\n* Unsure if numba accelerated functions can refer to other accelerated functions\n\t* Test case: adjacency code in mcMove; move into separate accelerated method\n\t\t* Can move it to separate function, but numba gets confused if it’s a class method\n\t\t* standardTest500: 6.9 s\n\nNumba seems to work; moving onto some architecture changes:\n* Current plan is to have inheritance structure w/specific dimension configs hard coded\n* 3 main differences between dimensions:\n\t\tDimension of array\n\t\tFirst initial state\n\t\tAdjacencies of cells\n* Cell adjacency seems the most complicated to generalise; however tuple indices may allow for \n* Numba is DIFFICULT to work with; it has the type stringency of a C language w/out significantly useful error messages\n\nFINALLY got the numba stuff working; still needs optimisatin; however everything is working in a generalised sense; I think a general N dimensional config object is doable now:\n\n* standardTest: 130.6 s\n* This is significantly worse than before; I thing its because of the generalised adjacency changes? Alternatively my laptop is on low battery with other stuff running on background; so may be that instead?\n* TBD another day\n\t* If it’s a genuine slowdown, may need to comb through and see if its possible to optimise\n\t* Adjacency code - may need to do that once per dimension case? May help reduce computation? Idk\n\n\n## 25/01/2026\nQuick test; still slow on full battery/restarted laptop; needs optimisation\n\n* spliting adjacency function \"getNeighbourIndices\" into two:\n\t* Get adjacency maps (array of addition/subtractions to be made) - can be done on basis of dimension once per config object\n\t* Adjacency maps can then be passed into \"getNeighbourIndices\" to add maps%size to desired index \n\t* Splitting computation should reduce repeat workload of finding adjacency maps\n* getArrayVal; can rewrite for loop in terms of array manipulations; unsure if it'd be faster given compilation, but numpy may have more efficient implementations\n\t* Maybe setup some default D=1,2,3,4,5 search cases; may be faster for defaults that are likely going to be used in this lab; then remaining code \n\t* getArrayVal uses a size^{currentDimension} array; it’s the same for configs of same dimension/size; precomputing this for each config may help (instead of recomputing it for each \n\t* flattenArray step may be movable to \"getNeighbours\" function instead? Demodularises the code, but would reduce repeat operations - could also pass in dimensionality as argument instead of evaluating it locally (again reducing repeat steps)\n* Maybe combine several functions - I wonder if calls between numba'd functions reverts to python, requiring recompilation and slowing down results\n\nPlan:\n\n* Combine config2D into config; code should work generalised:\n\t* Careful w/2D indices in mcMove and calcEnergy; need to generalize this\n* Ensure config object has information about its dimensionality\n* Have config object query its own adjacency maps in the constructor (to avoid repetition)\n* Have adjacency maps passed into Mcmove, and into getNeighbourIndices\n* Combine functionality of getArrayVal into getNeighbours - leave getArrayVal as is for now (may be useful for some general one off computations) but streamline getNeighbours for efficiency as outlined above\n\n* Test\n\n* If need be, maybe combine getNeighbourIndices into getNeighbours - if call between functions is slowing numba down, this is an efficiency gain (at the cost of modularity and legibility)\n\t* If need be combine this all into mcMove directly; preffer not to; modular code tends to be more legible, but it may be a worthwhile tradeoff; esp given that this code is the \"core\" of the simulation, and shouldn't need to be touched once its working properlyi\n\t\n\t\n### Log:\n\n* Problem - editing state Nd array is problematic w/numba\n\t* Workaround - don’t edit Nd array in mcMove; have mcMove return list of positions and associated values to run simulation; run simulation can then handle the editing\n\t\t* Have found workaround; involves array.reshape(tuple) instead of np.reshape(array, array) - does require passing through sizes array as tuple; but that can be saved once by the config\n* Have moved some functionality around\n\n* standardTest500; 83s - better but still not good\n* Edited main loop in Mcmove to loop over cells in config rather than over I, j - generalises loop\n* standardTest500; 8.8s - seems that editing main loop vastly improved performance\n\n* Quick test of 1D; broke - have noted #TODO in code\n\n\n## 26/01/2026 log:\n\n* Seems that editing main loop didn't iterate over all elements?\n\t* Fixed it; idk if there was actually a speedup\n\t* standardTest500; 96s\n* Have yet to separate adjacency check out\n\t* Have seperated out \"getNeighbourIndices\" into \"getNeighbourIndices\" and \"getAdjacencies\" - \"getAdjacencies\" finds the relative neighbour indices (I.E, [0, +-1]) for a given dimensionality - this is done once per config object and passed through to \"getNeighbourIndices\" - should reduce computation\n\t\t* Slight improvement:\n\t\t\t\tstandardTest500: 92s\n* Wondering if \"nested function calls\" is whats causing issues?\n\t* Quickly moving everything into mcMove - is a lot less modular, but may be more efficient, so worth testing\n\t\t\tstandardTest500: 87.4s\n\t\t\tSlight improvement - I suspect not duplicating the array flattening step is improving things\n\t\t\tMore tweaking:\n\t\t\tstandardTest500: 81.2s\n\t\t* More tweaking:\n\t\t* standardTest500: 62.1s\n\t\t* More tweaking (merged editArray into mcMoves)\n\t\t* standardTest500: 33.3s\n\t\t* More tweaking - changes how e^(−cost β)=〖(e〗^(−β))^(cost)  is computed - precomputing 〖(e〗^(−β)) to try and shave some more efficiency\n\t\t* standardTest500: 50s; have reverted change - presumably multiplication and one exp is easier on computer than alternative\n\t\t* Minor testing; commented out \"appendConfig(curConfig)\" from \"runSimulation\" - given 500 steps, that gets called a lot; want to quantify how significant a drain it represents\n\t\t* standardTest500: 23.4s\n\t\t\t\t□ Does represent a not insigificant improvement\n\t\t\t\t□ May be including a \"do not save\" option to runSimulation - have added - should help w/both run times and file sizes\n\n* Taken a break from optimisation to debug; have gotten it working in 1D case\n* General debugging complete; have quickly tested that 1D, 3D and 4D cases work; they do; have added graphing method to handle 3D case and rearranged graphing code a bit\n\n* Code still needs commenting/general tidying, but it is in a baseline \"complete\" state\n\n* Note; observing significant decrease in speed for higher dimension; setting up new test case:\n* standardTest3D100 = 20x20x20 over 100 steps\n* standardTest3D100: 562.6s (9.3min)\n* This is a significant increase from a 2D case; I suspect this will be significantly worse for even higher dimensions; as such it may be prudent to try and understand finite scaling effects in lower dimensions, and try and extrapolate that understanding to small higher dimensionality models as necessary\n\n\n* Note; incorrect implenentation of code (removing np.flip(currentIndex) operation on line 215) creates an incredibly interesting behaviour which includes:\n\t* Symetry along the x/y axis\n3 distinct cluster types; black, white, crosshatched","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"1_1_labLog.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","theme":["cosmo","brand"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}